%%
%% presentation.tex
%%
%% Made by Jakub Kuźma
%% Login   <kuba@jah.pl>
%%
%% Started on  Fri Oct 24 19:44:04 2008 Jakub Kuźma
%% Last update Fri Oct 24 19:44:04 2008 Jakub Kuźma
%%

\documentclass[12t]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[polish]{babel}
\usepackage{polski}
\usepackage{graphicx}
\usepackage{color}
\input{pygments}

\usetheme{Pittsburgh}

\author{Silesian Ruby Users' Group}
\title{Ruby on Rails}
\setbeamercovered{transparent}
%\setbeameroption{show notes}

\begin{document}

\frame{\titlepage}

\section{Wstęp}
\begin{frame}
  \frametitle{Dlaczego web development?}
  \begin{itemize}
  \item przenośność
  \item niezależność od systemów operacyjnych i przeglądarek
  \item łatwe zarządzanie i utrzymanie
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Dlaczego Ruby on Rails?}
  \begin{itemize}
  \item przyjemność z programowania
  \item open source
  \item czytelność kodu
  \item propagowanie dobrych praktyk programistycznych
  \item szybkość programowania
  \item łatwość reagowania na zmiany
  \item niezależność od systemu operacyjnego
  \item niezależność od środowiska pracy (NetBeans, RadRails, Emacs,
    Vim, JEdit)
  \end{itemize}
\end{frame}

\section{Ruby}
\begin{frame}
  \frametitle{Ruby}
  \begin{itemize}
  \item 1995 rok, Yukihiro Matsumoto aka Matz
  \item inspirowany przez CLU, Eiffel, Lisp, Perl, Python, Smalltalk
  \item interpretowany
  \item wieloparadygmatowy
  \item bardzo wysokiego poziomu (VHLL)
  \item w pełni obiektowy
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Cechy}
  \begin{itemize}
  \item dziedziczenie jednobazowe
  \item moduły - rodzaj dziedziczenia wielobazowego pozwalający
    włączyć gotową implementację zbioru metod do danej klasy
    (\emph{mixin})
    \note[item]{Moduły pełnią też rolę przestrzeni nazw}
  \item dziedziczenia używa się znacznie oszczędniej i rzadziej niż
    np. w Javie
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Cechy, c.d.}
  \begin{itemize}
  \item bogata biblioteka standardowa
  \item garbage collector
  \item przeciążanie operatorów
  \item liczby całkowite o dowolnych rozmiarach
  \item wyrażenia regularne wbudowane w składnię
  \end{itemize}
\end{frame}

\subsection{Ruby - implementacje}
\begin{frame}
  \frametitle{Ruby - implementacje}
  \begin{itemize}
  \item interpretery: MRI, Ruby Enterprise, JRuby, IronRuby
  \item maszyny wirtualne: MagLev, Rubinius, YARV
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Samokomentujący się kod}
  \input{selfcomment1}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Nazewnictwo}
  \begin{small}
    \input{naming1}
  \end{small}
  \note{Styl formatowania kodu nie jest narzucony z góry, wcięcia nie
    mają dla interpretera żadnego znaczenia}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stałe są zmienne}
  \input{consts1}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item omijane przez garbage collector
  \item wykorzystywane m.in. jako klucze w tablicach asocjacyjnych
  \end{itemize}
  \frametitle{Symbole}
  \begin{block}{Przykład}
    \input{symbols1}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Podstawowe elementy - tablice i hasze}
  \input{ruby1}
\end{frame}

\begin{frame}
  \begin{quote}
    “If it walks like a duck and quacks like a duck, I would call it a
    duck.”

    \hfill James Whitcomb Riley
  \end{quote}
\end{frame}

\begin{frame}
  \frametitle{Duck typing}
  \begin{itemize}
  \item rozpoznawanie typów na podstawie ich zachowania, a nie deklaracji
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Duck typing - przykład}
 \begin{footnotesize}
    \input{ducktyping1}
  \end{footnotesize}
\end{frame}

\begin{frame}
  \frametitle{Domknięcia}
  \begin{itemize}
  \item bloki kodu mogą być przekazywane jako argumenty i zwracane
    jako wynik działania funkcji (metody)
  \item są podstawową cechą języków funkcyjnych
  \item odwołują się do zmiennych z kontekstu, w którym zostały
    stworzone, a nie z którego są wywoływane
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Domknięcia - przykład}
  \input{closures1}
\end{frame}

\begin{frame}
  \frametitle{Domknięcia - wykorzystanie}
  \input{closures2}
\end{frame}

\subsection{Otwarte klasy}
\begin{frame}
  \frametitle{Otwarte klasy - przykład}
  \input{openclasses1}
  \note{Uzupełniamy klasę z biblioteki standardowej - używamy metody
    shuffle tak jakby była tam od zawsze.}
  \note{Ze względu na częste użycie metoda shuffle znalazła się w
    bibliotece standardowej w Ruby 1.8.7}
\end{frame}

\subsection{Monkey patching}
\begin{frame}
  \frametitle{Monkey patching - problem}
  \input{monkeypatching1}
  \note{Fajnie byłoby, gdyby metoda index przyjmowała blok i zwróciła
    w tym przypadku index równy 6}
\end{frame}

\begin{frame}
  \frametitle{Monkey patching - rozwiązanie}
  \input{monkeypatching2}
  \note{Podobnie jak w poprzednim przypadku - metoda index przyjmuje
    blok w Ruby 1.8.7}
\end{frame}

\subsection{Metaprogramowanie}
\begin{frame}
  \frametitle{Metaprogramowanie}
  \begin{itemize}
  \item metaprogramowanie w Rubim jest \textbf{proste}
  \item dysponujemy programowalnym językiem programowania
  \item główne narzędzie służące do budowy tzw. DSL
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Metaprogramowanie - przykład}
  \input{metaprogramming1}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Metaprogramowanie - przykład, c.d.}
  \input{metaprogramming2}
  \note{To nie jest specjalna składnia - to zwykłe wywołanie metody
    zadeklarowanej w klasie Module}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Metaprogramowanie - przykład, c.d.}
  \input{metaprogramming3}
  \note{Wiele osób w dalszym ciągu traci czas na pisanie getterów i
    setterów w np. Javie}
  \note{nie musimy pisać funkcji - attr_accessor, attr_reader,
    attr_writer są w bibliotece standardowej. Zostały napisane w C}
\end{frame}

\subsection{Użycie method\_missing}
\begin{frame}[fragile]
  \frametitle{Użycie method\_missing}
  \input{methodmissing1}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Użycie method\_missing, c.d.}
  \input{methodmissing2}
  \note{Dla zaoszczędzenia czasu nie będziemy prezentować jak osiągnąć
    ten efekt w tradycyjny sposób}
\end{frame}

\begin{frame}
  \frametitle{Podsumowanie}
  \begin{itemize}
  \item „pseudo-code that runs” - skupianie się na rozwiązaniu
    problemu, nie na języku
  \item język zaprojektowany \textbf{dla ludzi}
  \item radość z programowania
  \item TIMTOWTDI - wolność wyboru (jak w Perlu, przeciwnie niż w
    Pythonie)
  \item zasada najmniejszego zaskoczenia - Ruby jest intuicyjny
  \end{itemize}
  \note{Stworzony by cieszyć}
\end{frame}

\section{Ruby - dodatki}
\begin{frame}[fragile]
  \frametitle{Rake - Ruby Make}
  \begin{footnotesize}
    \input{rakefile1}
  \end{footnotesize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RSpec - framework BDD}
  \begin{footnotesize}
    \input{rspec1}
  \end{footnotesize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{RubyGems}
  \begin{itemize}
  \item system paczek RubyGems
  \item zależności pomiędzy gemami
  \item łatwa aktualizacja gemów
  \item prawie 4000 gemów w repozytorium
  \end{itemize}
  \begin{block}{Przykład}
\begin{verbatim}
$ gem install rails
\end{verbatim}
  \end{block}
\end{frame}

\begin{frame}
  \begin{quote}
    “I always thought Smalltalk would beat Java. I just
    didn't know it would be called 'Ruby' when it did.”

    \hfill Kent Beck
  \end{quote}
\end{frame}

\section{Ruby on Rails}
\begin{frame}
  \frametitle{Ruby on Rails}
  \begin{itemize}
  \item David Heinemeier Hansson, 2004 r.
  \item kompletny framework do tworzenia aplikacji internetowych
    opartych o bazy danych
  \item wzorzec MVC
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Rails way}
  \begin{itemize}
  \item Convention over Configuration
  \item Don't Repeat Yourself
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Z czego składa się Rails?}
  \begin{itemize}
  \item ActiveRecord
  \item ActionPack
  \item ActiveResource
  \item ActionMailer
  \item ActiveSupport
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Architektura Rails}
  \begin{figure}
    \centering
    \includegraphics[width=\linewidth]{railsarchitecture.png}
  \end{figure}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Zaczynamy!}
  \begin{columns}[T]
    \begin{column}{2.3cm}
      \includegraphics[width=2.3cm]{structure.png}
    \end{column}
    \begin{column}{7.5cm}
\begin{verbatim}
# gem install rails

$ rails myapp

$ cd myapp

$ ./script/server
\end{verbatim}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord}
  \begin{itemize}
  \item domyślny ORM dla Rails
  \item są też inne opcje (np. DataMapper)
  \item implementacja wzorca Active Record
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - co dostajemy?}
  \begin{itemize}
  \item prosta konfiguracja
  \item migracje bazy danych
  \item proste tworzenie asocjacji
  \item zapytania
  \item walidatory
  \item wywołania zwrotne
  \item transakcje
  \item kilka innych rzeczy
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - szybki start}
\begin{verbatim}
development:
  adapter: mysql
  database: demo
  username: admin
  password: password
  host: localhost
\end{verbatim}
\begin{verbatim}
$ ./script/generate model post title:string content:text

$ rake db:migrate
\end{verbatim}
  \input{configuration1}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - migracje}
  \begin{itemize}
  \item proste w użyciu wersjonowanie schematu bazy, historia zmian
  \item Ruby zamiast SQL-a
    \note{Uzyskujemy przenośność pomiędzy różnymi silnikami
      bazodanowymi}
  \item praca w zespołach
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - migracje - przykład}
  \input{migrations1}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - asocjacje}
  \begin{itemize}
  \item mapowanie powiązań pomiędzy obiektami ActiveRecord
  \item wyrażają relację takie jak “user has many projects” czy
    “product belongs to category”
  \item oparte na metaprogramowaniu
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - asocjacje - przykład}
  \input{associations1}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - asocjacje - przykład, c.d.}
  \input{associations2}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - zapytania}
  \begin{itemize}
  \item Różne sposoby budowania zapytań
  \item Nazwane zapytania
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - przykłady zapytań}
  \begin{footnotesize}
    \input{finders1}
  \end{footnotesize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - przykłady zapytań c.d.}
  \begin{footnotesize}
    \input{finders2}
  \end{footnotesize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - przykłady zapytań c.d.}
  \begin{small}
    \input{finders3}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Named scope - przykłady}
  \begin{small}
    \input{namedscope1}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - walidatory}
  \begin{itemize}
  \item gwarantują poprawność wprowadzanych danych
  \item przeniesienie walidacji z poziomu bazy danych do modelu
  \item można walidować: format, długość, obecność, unikalność,
    powiązane obiekty, etc.
  \item łatwe tworzenie własnych walidatorów
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - walidatory - przykład}
  \input{validators1}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - wywołania zwrotne}
  \begin{itemize}
  \item wyzwalanie logiki przed lub po zmianie stanu obiektu
  \item manipulacja atrybutami obiektu przed jego utworzeniem,
    zapisem, usunięciem lub walidacją
  \item przeniesienie logiki z kontrolera do modelu
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - callbacks - przykład}
  \input{callbacks1}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - transakcje}
  \begin{itemize}
  \item bloki kodu, w których gwarantowana jest atomowość wszystkich
    operacji na bazie danych
  \item różne modele w jednej transakcji
  \end{itemize}
  \begin{block}{Przykład}
    \input{transactions1}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord}
  \begin{itemize}
  \item Single Table Inheritance
  \item asocjacje polimorficzne
  \item optimistic locking
  \item acts\_as: state\_machine, taggable, nested\_set, commentable,
    dictionary, geocodable
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{quote}
    “I have never seen an Active Record implementation as complete or as useful as Rails”

    \begin{small}
      \hfill Martin Fowler, software architect
    \end{small}
  \end{quote}
  \note{M.Fowler jest autorem książek i znanym wykładowcą z tematyki
    architektury oprogramowania, specjalizującym się w analizie
    obiektowej i projektowaniu, UML, wzorcach projektowych, metodykach
    zwinnych, w tym Programowania ekstremalnego}
\end{frame}

\begin{frame}
  \frametitle{ActionPack}
  \begin{itemize}
  \item podział odpowiedzi aplikacji na dwie części:
    \begin{itemize}
    \item ActionController
    \item ActionView
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActionPack::ActionController}
  \begin{itemize}
  \item request zostaje skierowany do odpowiedniej akcji (routing)
  \item akcja zwraca odpowiedź do przeglądarki
    \begin{itemize}
    \item wyrenderowany widok
    \item przekierowanie
    \item błąd
    \end{itemize}
  \item cookies
  \item sesje
  \item flash
  \item filtry
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActionController::Routing}
  \begin{itemize}
  \item wiązanie URI z akcjami odpowiednich kontrolerów
  \end{itemize}
  \begin{block}{Przykład}
    \input{routing1}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{ActionPack::ActionController}
  \begin{small}
  \input{actioncontroller1}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{ActionPack::ActionView}
  \begin{itemize}
  \item szablony w widokach: ERb, Haml, Liquid i inne
  \item partiale
  \item helpery
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActionPack::ActionView - index.html.erb}
  \input{erb1}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActionPack::ActionView - index.html.haml}
  \begin{footnotesize}
  \begin{columns}[T]
    \begin{column}{4cm}
      \input{haml1}
    \end{column}
    \begin{column}{6cm}
      \input{haml2}
    \end{column}
  \end{columns}
  \end{footnotesize}
\end{frame}

\begin{frame}
  \frametitle{ActiveSupport}
  \input{activesupport}
\end{frame}

\begin{frame}
  \frametitle{Serwery HTTP}
  \begin{itemize}
  \item Webrick
  \item Mongrel, Thin, Ebb
  \item Passenger (Apache 2)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Przykłady wdrożeń}
  \begin{itemize}
  \item Twitter
  \item Yellowpages
  \item Basecamp
  \item GitHub
  \item Shopify
  \item Slideshare
  \end{itemize}
\end{frame}

\section{Podsumowanie}
\begin{frame}
  \frametitle{Jak zacząć?}
  \begin{itemize}
  \item instant-rails
  \item github.com
  \item opensourcerails.com
  \item heroku.com
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{quote}
    “Rails is the most well thought-out web development framework I've
    ever used. (...) Nobody has done it like this before.”

    \begin{small}
      \hfill James Duncan Davidson, Creator of Tomcat and Ant
    \end{small}
  \end{quote}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{Large}
      Dziękujemy za wytrwałość!
    \end{Large}
  \end{center}
\end{frame}

\end{document}
