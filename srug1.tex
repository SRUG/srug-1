%%
%% presentation.tex
%%
%% Made by Jakub Kuźma
%% Login   <kuba@jah.pl>
%%
%% Started on  Fri Oct 24 19:44:04 2008 Jakub Kuźma
%% Last update Fri Oct 24 19:44:04 2008 Jakub Kuźma
%%

\documentclass[12t]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage[polish]{babel}
\usepackage{graphicx}
\usepackage{color}
\input{pygments}

\usetheme{Pittsburgh}
\author{Silesian Ruby Users' Group}
\title{Ruby on Rails}
\setbeamercovered{transparent}
%\setbeameroption{show notes}

\begin{document}

\frame{\titlepage}

\section{Wstęp}
\begin{frame}
  \frametitle{Dlaczego web development?}
  \begin{itemize}
  \item przenośność
  \item niezależność od systemów operacyjnych i przeglądarek
  \item łatwe zarządzanie i utrzymanie
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Dlaczego Ruby on Rails?}
  \begin{itemize}
  \item przyjemność z programowania
  \item open source
  \item czytelność kodu
  \item propagowanie dobrych praktyk programistycznych
  \item szybkość programowania
  \item łatwość reagowania na zmiany
  \item niezależność od systemu operacyjnego
  \item niezależność od środowiska pracy (NetBeans, RadRails, Emacs,
    Vim, JEdit)
  \end{itemize}
\end{frame}

\section{Ruby}
\begin{frame}
  \frametitle{Ruby}
  \begin{itemize}
  \item 1995 rok, Yukihiro Matsumoto aka Matz
  \item inspirowany przez CLU, Eiffel, Lisp, Perl, Python, Smalltalk
  \item interpretowany
  \item bardzo wysokiego poziomu (VHLL)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Ruby, c.d.}
  \begin{itemize}
  \item w pełni obiektowy
  \item prosta składnia, samokomentujący się kod
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Duck typing}
  \begin{itemize}
  \item rozpoznawanie typów na podstawie ich zachowania, a nie deklaracji
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{quote}
    “If it walks like a duck and quacks like a duck, I would call it a
    duck.”

    \hfill James Whitcomb Riley
  \end{quote}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item bloki i lambdy (domknięcia) - wygodne przekazywanie funkcji
    jako parametrów + przykład
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Cechy}
  \begin{itemize}
  \item dziedziczenie jednobazowe
  \item moduły zapewniają rodzaj dziedziczenia wielobazowego
    pozwalający włączyć gotową implementację zbioru metod do danej
    klasy (\emph{mixin})
    \note[item]{Moduły pełnią też rolę przestrzeni nazw}
  \item dziedziczenia używa się znacznie oszczędniej i rzadziej niż
    np. w Javie
  \item styl formatowania kodu nie jest narzucony z góry
    \note[item]{Wcięcia nie mają żadnego znaczenia dla kompilatora}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Cechy, c.d.}
  \begin{itemize}
  \item bogata biblioteka standardowa
  \item garbage collector
  \item przeciążanie operatorów
  \item liczby całkowite o dowolnych rozmiarach
  \item wyrażenia regularne wbudowane w składnię
  \end{itemize}
\end{frame}

\subsection{Otwarte klasy}
\begin{frame}
  \frametitle{Otwarte klasy - przykład}
  \input{openclasses1}
  \note{Uzupełniamy klasę z biblioteki standardowej - używamy metody
    shuffle tak jakby była tam od zawsze.}
  \note{Ze względu na częste użycie metoda shuffle znalazła się w
    bibliotece standardowej w Ruby 1.8.7}
\end{frame}

\subsection{Monkey patching}
\begin{frame}
  \frametitle{Monkey patching - przykład}
  \input{monkeypatching1}
\end{frame}

\begin{frame}
  \frametitle{Monkey patching - przykład, c.d.}
  \input{monkeypatching2}
\end{frame}

\subsection{Metaprogramowanie}

\begin{frame}
  \frametitle{Metaprogramowanie}
  \begin{itemize}
  \item metaprogramowanie w Rubim jest \textbf{proste}
  \item dysponujemy programowalnym językiem programowania
  \item główne narzędzie służące do budowy tzw. DSL
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Metaprogramowanie - przykład}
  \input{metaprogramming1}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Metaprogramowanie - przykład, c.d.}
  \input{metaprogramming2}
  \note{To nie jest specjalna składnia - to zwykłe wywołanie metody
    zadeklarowanej w klasie Module}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Metaprogramowanie - przykład, c.d.}
  \input{metaprogramming3}
  \note{Wiele osób w dalszym ciągu traci czas na pisanie getterów i
    setterów w np. Javie}
  \note{nie musimy pisać funkcji - attr_accessor, attr_reader,
    attr_writer są w bibliotece standardowej. Zostały napisane w C}
\end{frame}

\subsection{Użycie method\_missing}
\begin{frame}[fragile]
  \frametitle{Użycie method\_missing}
  \input{methodmissing1}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Użycie method\_missing, c.d.}
  \input{methodmissing2}
  \note{Dla zaoszczędzenia czasu nie będziemy prezentować jak osiągnąć
    ten efekt w tradycyjny sposób}
\end{frame}

\begin{frame}
  \frametitle{Podsumowanie}
  \begin{itemize}
  \item „pseudo-code that runs” - skupianie się na rozwiązaniu
    problemu, nie na języku
  \item język zaprojektowany \textbf{dla ludzi}
  \item radość z programowania
  \item TIMTOWTDI - wolność wyboru (jak w Perlu, przeciwnie niż w
    Pythonie), konwencje pozwalają na uniknięcie typowego „perlarstwa”
  \item zasada najmniejszego zaskoczenia - Ruby jest intuicyjny
  \end{itemize}
  \note{Stworzony by cieszyć}
\end{frame}

\section{Ruby on Rails}
\begin{frame}
  \frametitle{Ruby on Rails}
  \begin{itemize}
  \item David Heinemeier Hansson, 2004 r.
  \item kompletny framework do tworzenia aplikacji internetowych
    opartych o bazy danych
  \item wzorzec MVC
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Rails way}
  \begin{itemize}
  \item Jeden sposób na zaprojektowanie aplikacji webowej
  \item Convention over Configuration
  \item Don't Repeat Yourself
  \item Fat model, thin controller w MVC
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Z czego składa się Rails?}
  \begin{itemize}
  \item ActiveRecord
  \item ActionPack
  \item ActiveResource
  \item ActionMailer
  \item ActiveSupport
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord}
  \begin{itemize}
  \item domyślny ORM dla Rails
  \item są też inne opcje (np. DataMapper)
  \item implementacja wzorca Active Record
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{quote}
    I have never seen an Active Record implementation as complete or as useful as Rails

    \hfill Martin Fowler
  \end{quote}
  \note{M.Fowler jest autorem książek i znanym wykładowcą z tematyki
    architektury oprogramowania, specjalizującym się w analizie
    obiektowej i projektowaniu, UML, wzorcach projektowych, metodykach
    zwinnych, w tym Programowania ekstremalnego}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - co dostajemy?}
  \begin{itemize}
  \item brak XML-a
  \item migracje bazy danych
  \item proste tworzenie asocjacji
  \item walidatory
  \item callbacki
  \item transakcje
  \item masę innych rzeczy...
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - Brak XML}
  \begin{itemize}
  \item nie wymaga konfiguracji za pomocą setek linii XML-a
  \item mapowanie tabel na modele - konwencje nad konfiguracją
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - YAML w akcji}
\begin{verbatim}
development:
  adapter: mysql
  database: demo
  username: admin
  password: password
  host: localhost
\end{verbatim}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - Migracje}
  \begin{itemize}
  \item proste w użyciu wersjonowanie schematu bazy, historia zmian
  \item Ruby zamiast SQL-a
    \note{Uzyskujemy przenośność pomiędzy różnymi silnikami
      bazodanowymi}
  \item praca w zespołach
  \item synchronizacja
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - Migracje - przykład}
  \input{migrations1}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - Asocjacje}
  \begin{itemize}
  \item mapowanie pomiędzy obiektami ActiveRecord
  \item wyrażają relację takie jak ,,Użytkownik ma wiele Projektów''
    czy ,,Produkt należy do Kategorii''
  \item oparte na metaprogramowaniu
  \item wczesne ładowanie obiektów
  \item połączenia wiele-do-wielu
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - Asocjacje - przykład}
  \input{associations1}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ActiveRecord - Asocjacje - przykład, c.d.}
  \input{associations1}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - Walidatory}
  \begin{itemize}
  \item gwarantują poprawne dane w bazie
  \item przeniesienie walidacji z poziomu bazy danych do mapowanych
    obiektów
  \item można walidować: format, długość, obecność, unikalność,
    powiązane obiekty, etc.
  \item łatwe dodawanie własnych walidatorów
  \item metaprogramowanie
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - Walidatory - przykład}
  \input{validators1}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - Callbacki}
  \begin{itemize}
  \item wyzwalanie logiki przed lub po zmianie stanu obiektu
  \item manipulacja atrybutami obiektu przed jego utworzeniem,
    zapisem, usunięciem lub walidacją
  \item przeniesienie logiki z kontrolera do modelu
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - Callbacki - przykład}
  kod
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - Transakcje}
  \begin{itemize}
  \item bloki kodu, w których gwarantowana jest atomowość wszystkich
    operacji na bazie danych
  \item różne modele w jednej transakcji
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord - Transakcje - przykład}
  \input{transactions1}
\end{frame}

\begin{frame}
  \frametitle{ActiveRecord}
  \begin{itemize}
  \item Single Table Inheritance
  \item asocjacje polimorficzne
  \item cache-owanie
  \item acts\_as: state\_machine, taggable, nested\_set, commentable,
    dictionary, geocodable
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActionPack}
  \begin{itemize}
  \item podział odpowiedzi aplikacji na dwie części:
    \begin{itemize}
    \item ActionController
    \item ActionView
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActionPack::ActionController}
  \begin{itemize}
  \item akcje w kontrolerze
  \item akcja renderuje daną stronę, wywołuje inną akcję bądź zwracają zasoby (REST)
  \item sesje
  \item flash
  \item callbacki
  \item akcje CRUD
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActionPack::ActionController}
  przykłady ActionController
\end{frame}

\begin{frame}
  \frametitle{ActionPack::ActionView}
  \begin{itemize}
  \item szablony w widokach: ERb, Haml, Liquid i inne
  \item partiale
  \item helpery
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActionPack::ActionView}
  przykłady ActionView
\end{frame}

\begin{frame}
  \frametitle{ActiveResource}
  mapowanie RESTowych zasobów jako modele
\end{frame}

\begin{frame}
  \frametitle{ActionMailer}
  \begin{itemize}
  \item wbudowany system do rozsyłania i odbierania poczty email
  \item sendmail, IMAP
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ActiveSupport}
\end{frame}

\begin{frame}
  serwery HTTP: Webrick, Mongrel, Thin, Ebb, Passenger(Apache)
\end{frame}

\begin{frame}
  Przykłady wdrożeń
\end{frame}

\section{Ruby - dodatki}
\begin{frame}
  \frametitle{RubyGems}
  system paczek: gem install rails
\end{frame}

\begin{frame}
  \frametitle{Rake}
  \begin{itemize}
  \item Rake - Ruby Make
  \item przykłady
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{RSpec}
  \begin{itemize}
  \item framework BDD
  \item przykłady
  \end{itemize}
\end{frame}

\section{Ruby - rozwój}
\begin{frame}
  \frametitle{Ruby - rozwój}
  \begin{itemize}
  \item implementacje: MRI, Ruby Enterprise, JRuby, IronRuby
  \item maszyny wirtualne: MagLev, Rubinius, YARV
  \item Github
  \end{itemize}
\end{frame}

\section{Ruby - podsumowanie}
\begin{frame}
  \frametitle{Jak zacząć}
  \begin{itemize}
  \item instant-rails
  \item github
  \item opensourcerails.com
  \item heroku.com
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Po 3 latach z Ruby - co się zmienia}
  \begin{itemize}
  \item Ruby jako pierwszy pozwolił mi czerpać radość z
    programowania. Wcześniej były Java, w C/C++ i inne
  \item Pragmatyzm. Prosty, czytelny kod. Mało kodu. Brak
    komentarzy. Więcej czasu na życie.
  \item Nie wrócę do już do języków ze statycznym typowaniem. Czytałem
    Bruca Eckela kiedy mówił, że statyczne typowanie to przyszłość. Po
    latach zmienił zdanie. To samo dotyczy deklarowania wyrzucanych
    wyjątków (patrz Java).
  \item Większy dystans i szersze spojrzenie na rzemiosło programowania.
  \item 1 nowy język programowania co roku (ObjC, Erlang, Lisp, ...)
  \end{itemize}
\end{frame}

\end{document}
